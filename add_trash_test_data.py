#!/usr/bin/env python3
"""
Script pour ajouter des donn√©es de test dans la corbeille ESAG GED
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from AppFlask.db import db_connection
from psycopg2.extras import RealDictCursor
from datetime import datetime, timedelta
import json
import random

def add_test_trash_data():
    """Ajouter des donn√©es de test dans la corbeille"""
    print("üóëÔ∏è AJOUT DE DONN√âES DE TEST DANS LA CORBEILLE")
    print("=" * 50)
    
    try:
        conn = db_connection()
        if not conn:
            print("‚ùå Erreur de connexion √† la base de donn√©es")
            return False
        
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        
        # R√©cup√©rer les utilisateurs existants
        cursor.execute("SELECT id, nom, prenom FROM utilisateur LIMIT 5")
        users = cursor.fetchall()
        
        if not users:
            print("‚ùå Aucun utilisateur trouv√©")
            return False
        
        print(f"üë• {len(users)} utilisateurs trouv√©s")
        
        # Donn√©es de test pour diff√©rents types d'√©l√©ments
        test_documents = [
            {
                'titre': 'Rapport financier Q4 2024',
                'description': 'Rapport trimestriel des finances',
                'fichier': 'rapport_q4_2024.pdf',
                'taille': 2048576,  # 2MB
                'mime_type': 'application/pdf'
            },
            {
                'titre': 'Pr√©sentation projet Alpha',
                'description': 'Slides de pr√©sentation du nouveau projet',
                'fichier': 'presentation_alpha.pptx',
                'taille': 5242880,  # 5MB
                'mime_type': 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
            },
            {
                'titre': 'Contrat client XYZ',
                'description': 'Contrat sign√© avec le client XYZ Corp',
                'fichier': 'contrat_xyz.docx',
                'taille': 1048576,  # 1MB
                'mime_type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            },
            {
                'titre': 'Base de donn√©es clients',
                'description': 'Export de la base de donn√©es clients',
                'fichier': 'clients_export.xlsx',
                'taille': 3145728,  # 3MB
                'mime_type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            },
            {
                'titre': 'Photos √©v√©nement corporate',
                'description': 'Photos de l\'√©v√©nement d\'entreprise',
                'fichier': 'photos_event.zip',
                'taille': 52428800,  # 50MB
                'mime_type': 'application/zip'
            },
            {
                'titre': 'Manuel utilisateur v2.1',
                'description': 'Documentation utilisateur mise √† jour',
                'fichier': 'manuel_v2.1.pdf',
                'taille': 4194304,  # 4MB
                'mime_type': 'application/pdf'
            },
            {
                'titre': 'Facture fournisseur ABC',
                'description': 'Facture du fournisseur ABC pour mat√©riel',
                'fichier': 'facture_abc_001.pdf',
                'taille': 512000,  # 500KB
                'mime_type': 'application/pdf'
            },
            {
                'titre': 'Backup configuration serveur',
                'description': 'Sauvegarde des configurations serveur',
                'fichier': 'server_config_backup.json',
                'taille': 102400,  # 100KB
                'mime_type': 'application/json'
            }
        ]
        
        test_folders = [
            {
                'nom': 'Archives 2023',
                'description': 'Dossier d\'archives pour l\'ann√©e 2023'
            },
            {
                'nom': 'Projets abandonn√©s',
                'description': 'Dossier contenant les projets non aboutis'
            },
            {
                'nom': 'Temp - √† trier',
                'description': 'Dossier temporaire pour documents √† classer'
            },
            {
                'nom': 'Brouillons marketing',
                'description': 'Brouillons de campagnes marketing'
            }
        ]
        
        # R√©cup√©rer la configuration de r√©tention
        cursor.execute("""
            SELECT setting_value::INTEGER as retention_days 
            FROM trash_config 
            WHERE setting_name = 'retention_days'
        """)
        retention_config = cursor.fetchone()
        retention_days = retention_config['retention_days'] if retention_config else 30
        
        print(f"‚è∞ Dur√©e de r√©tention configur√©e: {retention_days} jours")
        
        # Ajouter des documents dans la corbeille
        print("\nüìÑ Ajout de documents de test...")
        doc_count = 0
        
        for i, doc_data in enumerate(test_documents):
            user = random.choice(users)
            
            # Dates vari√©es (certains r√©cents, d'autres plus anciens)
            days_ago = random.randint(1, retention_days - 5)
            deleted_at = datetime.now() - timedelta(days=days_ago)
            expiry_date = deleted_at + timedelta(days=retention_days)
            
            # Raisons de suppression vari√©es
            deletion_reasons = [
                "Document obsol√®te",
                "Suppression par l'utilisateur",
                "Nettoyage de dossier",
                "Version remplac√©e",
                "Erreur de cr√©ation",
                "Projet annul√©"
            ]
            
            cursor.execute("""
                INSERT INTO trash (
                    item_id, item_type, item_data, deleted_by, deleted_at,
                    expiry_date, size_bytes, deletion_reason
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                1000 + i,  # ID fictif
                'document',
                json.dumps(doc_data),
                user['id'],
                deleted_at,
                expiry_date,
                doc_data['taille'],
                random.choice(deletion_reasons)
            ))
            
            doc_count += 1
            print(f"   ‚úÖ {doc_data['titre']} (supprim√© il y a {days_ago} jours)")
        
        # Ajouter des dossiers dans la corbeille
        print(f"\nüìÅ Ajout de dossiers de test...")
        folder_count = 0
        
        for i, folder_data in enumerate(test_folders):
            user = random.choice(users)
            
            days_ago = random.randint(5, retention_days - 2)
            deleted_at = datetime.now() - timedelta(days=days_ago)
            expiry_date = deleted_at + timedelta(days=retention_days)
            
            cursor.execute("""
                INSERT INTO trash (
                    item_id, item_type, item_data, deleted_by, deleted_at,
                    expiry_date, size_bytes, deletion_reason
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                2000 + i,  # ID fictif
                'folder',
                json.dumps(folder_data),
                user['id'],
                deleted_at,
                expiry_date,
                0,  # Les dossiers n'ont pas de taille directe
                "R√©organisation des dossiers"
            ))
            
            folder_count += 1
            print(f"   ‚úÖ {folder_data['nom']} (supprim√© il y a {days_ago} jours)")
        
        # Ajouter quelques √©l√©ments restaur√©s pour les statistiques
        print(f"\n‚ôªÔ∏è Ajout d'√©l√©ments restaur√©s...")
        restored_count = 0
        
        for i in range(3):
            user = random.choice(users)
            
            doc_data = {
                'titre': f'Document restaur√© {i+1}',
                'description': 'Document qui a √©t√© restaur√© depuis la corbeille',
                'fichier': f'restored_doc_{i+1}.pdf',
                'taille': random.randint(500000, 2000000),
                'mime_type': 'application/pdf'
            }
            
            deleted_at = datetime.now() - timedelta(days=random.randint(10, 20))
            restored_at = deleted_at + timedelta(days=random.randint(1, 5))
            
            cursor.execute("""
                INSERT INTO trash (
                    item_id, item_type, item_data, deleted_by, deleted_at,
                    restored_at, restored_by, size_bytes, deletion_reason
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                3000 + i,  # ID fictif
                'document',
                json.dumps(doc_data),
                user['id'],
                deleted_at,
                restored_at,
                user['id'],
                doc_data['taille'],
                "Test de restauration"
            ))
            
            restored_count += 1
            print(f"   ‚úÖ {doc_data['titre']} (restaur√©)")
        
        # Ajouter quelques √©l√©ments supprim√©s d√©finitivement
        print(f"\nüî• Ajout d'√©l√©ments supprim√©s d√©finitivement...")
        deleted_count = 0
        
        for i in range(2):
            user = random.choice(users)
            
            doc_data = {
                'titre': f'Document supprim√© d√©finitivement {i+1}',
                'description': 'Document supprim√© de fa√ßon permanente',
                'fichier': f'deleted_doc_{i+1}.pdf',
                'taille': random.randint(100000, 1000000),
                'mime_type': 'application/pdf'
            }
            
            deleted_at = datetime.now() - timedelta(days=random.randint(25, 35))
            permanent_delete_at = deleted_at + timedelta(days=retention_days + 1)
            
            cursor.execute("""
                INSERT INTO trash (
                    item_id, item_type, item_data, deleted_by, deleted_at,
                    permanent_delete_at, permanent_delete_by, size_bytes, deletion_reason
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                4000 + i,  # ID fictif
                'document',
                json.dumps(doc_data),
                user['id'],
                deleted_at,
                permanent_delete_at,
                0,  # 0 = suppression automatique
                doc_data['taille'],
                "Nettoyage automatique"
            ))
            
            deleted_count += 1
            print(f"   ‚úÖ {doc_data['titre']} (supprim√© d√©finitivement)")
        
        conn.commit()
        cursor.close()
        conn.close()
        
        # R√©sum√©
        total_items = doc_count + folder_count + restored_count + deleted_count
        print(f"\nüìä R√âSUM√â DES DONN√âES AJOUT√âES")
        print("=" * 35)
        print(f"üìÑ Documents en corbeille: {doc_count}")
        print(f"üìÅ Dossiers en corbeille: {folder_count}")
        print(f"‚ôªÔ∏è √âl√©ments restaur√©s: {restored_count}")
        print(f"üî• √âl√©ments supprim√©s d√©finitivement: {deleted_count}")
        print(f"üìä Total: {total_items} √©l√©ments")
        
        print(f"\n‚úÖ Donn√©es de test ajout√©es avec succ√®s!")
        print(f"üéØ Vous pouvez maintenant tester l'interface de la corbeille")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors de l'ajout des donn√©es: {e}")
        if 'conn' in locals():
            conn.rollback()
            cursor.close()
            conn.close()
        return False

def check_existing_data():
    """V√©rifier les donn√©es existantes dans la corbeille"""
    print("üîç V√âRIFICATION DES DONN√âES EXISTANTES")
    print("=" * 40)
    
    try:
        conn = db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        
        # Compter les √©l√©ments par statut
        cursor.execute("""
            SELECT 
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE restored_at IS NULL AND permanent_delete_at IS NULL) as pending,
                COUNT(*) FILTER (WHERE restored_at IS NOT NULL) as restored,
                COUNT(*) FILTER (WHERE permanent_delete_at IS NOT NULL) as deleted,
                COALESCE(SUM(size_bytes), 0) as total_size
            FROM trash
        """)
        
        stats = cursor.fetchone()
        
        print(f"üìä Statistiques actuelles:")
        print(f"   - Total √©l√©ments: {stats['total']}")
        print(f"   - En attente: {stats['pending']}")
        print(f"   - Restaur√©s: {stats['restored']}")
        print(f"   - Supprim√©s d√©finitivement: {stats['deleted']}")
        print(f"   - Taille totale: {stats['total_size']} bytes")
        
        # Compter par type
        cursor.execute("""
            SELECT item_type, COUNT(*) as count
            FROM trash
            WHERE restored_at IS NULL AND permanent_delete_at IS NULL
            GROUP BY item_type
        """)
        
        types = cursor.fetchall()
        if types:
            print(f"\nüìã Par type d'√©l√©ment:")
            for type_info in types:
                print(f"   - {type_info['item_type']}: {type_info['count']}")
        
        cursor.close()
        conn.close()
        
        return stats['total'] > 0
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification: {e}")
        return False

def main():
    """Fonction principale"""
    print("üóëÔ∏è GESTIONNAIRE DE DONN√âES DE TEST - CORBEILLE ESAG GED")
    print("=" * 60)
    
    # V√©rifier les donn√©es existantes
    has_data = check_existing_data()
    
    if has_data:
        print(f"\n‚ö†Ô∏è Des donn√©es existent d√©j√† dans la corbeille.")
        response = input("Voulez-vous ajouter plus de donn√©es de test ? (o/N): ")
        if response.lower() not in ['o', 'oui', 'y', 'yes']:
            print("üö´ Op√©ration annul√©e")
            return
    
    # Ajouter les donn√©es de test
    success = add_test_trash_data()
    
    if success:
        print(f"\nüéâ Configuration termin√©e!")
        print(f"üöÄ Le syst√®me de corbeille est pr√™t avec des donn√©es de test")
        print(f"üí° Vous pouvez maintenant:")
        print(f"   - Tester l'interface web √† http://localhost:3000/corbeille")
        print(f"   - Utiliser l'API REST pour les op√©rations")
        print(f"   - Configurer les param√®tres de r√©tention")
    else:
        print(f"\n‚ùå √âchec de la configuration")

if __name__ == "__main__":
    main() 